库存扣多了，到底怎么整

业务复杂、数据量大、并发量大的业务场景下，典型的互联网架构，一般会分为这么几层：

•调用层，一般是处于端上的browser或者APP
•站点层，一般是拼装html或者json返回的web-server层
•服务层，一般是提供RPC调用接口的service层
•数据层，提供固化数据存储的db

对于库存业务，一般有个库存服务，提供库存的查询、扣减、设置等RPC接口：
库存服务
•库存查询，stock-service本质上执行的是
select num from stock where sid=$sid
•库存扣减，stock-service本质上执行的是
update stock set num=num-$reduce where sid=$sid
•库存设置，stock-service本质上执行的是
update stock set num=$num_new where sid=$sid

用户下单前，一般会对库存进行查询，有足够的存量才允许扣减：
库存查询
如上图所示，通过查询接口，得到库存是5。

用户下单时，接着会对库存进行扣减：
库存扣减
如上图所示，购买3单位的商品，通过扣减接口，最终得到库存是2。

希望设计往往有容错机制，例如“重试”，如果通过扣减接口来修改库存，在重试时，可能会得到错误的数据，导致重复扣减：
库存容错机制
如上图所示，如果数据库层面有重试容错机制，可能导致一次扣减执行两次，最终得到一个负数的错误库存。



重试导致错误的根本原因，是因为“扣减”操作是一个非幂等的操作，不能够重复执行，改成设置操作则不会有这个问题：
库存幂等操作
如上图所示，同样是购买3单位的商品，通过设置库存操作，即使有重试容错机制，也不会得到错误的库存，设置库存是一个幂等操作。

在并发量很大的情况下，还会有其他的问题：
库存并发操作
如上图所示，两个并发的操作，查询库存，都得到了库存是5。

接下来用户发生了并发的购买动作（秒杀类业务特别容易出现）：
库存并发操作2
如上图所示：
•用户1购买了3个库存，于是库存要设置为2
•用户2购买了2个库存，于是库存要设置为3
•这两个设置库存的接口并发执行，库存会先变成2，再变成3，导致数据不一致（实际卖出了5件商品，但库存只扣减了2，最后一次设置库存会覆盖和掩盖前一次并发操作）

其根本原因是，设置操作发生的时候，没有检查库存与查询出来的库存有没有变化，理论上：
•库存为5时，用户1的库存设置才能成功
•库存为5时，用户2的库存设置才能成功

实际执行的时候：
•库存为5，用户1的set stock 2确实应该成功
•库存变为2了，用户2的set stock 3应该失败掉

升级修改很容易，将库存设置接口，stock-service上执行的：
update stock set num=$y where sid=$sid
升级为：
update stock set num=$num_new where sid=$sid and num=$num_old
这正是大家常说的“Compare And Set”（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。

总结
在业务复杂，数据量大，并发量大的情况下，库存扣减容易引发数据的不一致，常见的优化方案有两个：
•调用“设置库存”接口，能够保证数据的幂等性
•在实现“设置库存”接口时，需要加上原有库存的比较，才允许设置成功，能解决高并发下库存扣减的一致性问题

希望大伙有收获。

昨天一篇《库存扣多了，到底怎么整》，核心观点是：
•用“设置库存”替代“扣减库存”，以保证幂等性
•使用CAS乐观锁，在“设置库存”时加上原始库存的比对，避免数据不一致

文章非常多朋友留言发表观点，“架构师之路”能引发不少同学思考，甚是欣慰。

原以为两个核心观点应该是没有疑义的，结果很多朋友说方案不好，今天交流下部分回复的方案，个人的一些看法。

留言一
是否能使用
update stock set num=num-$count where sid=$sid and stock>=$count;
的方式扣减库存？
回答：这个方案无法保证幂等性，有可能出现重复扣减。

留言二
把库存放到reids里，利用redis的事务性来扣减库存。
分析：
redis是如何实现事务操作的？
本质也是乐观锁。

在redis客户端执行：
$num = GET key
$num = $num - $count
SET key $num
在并发量大的时候，会遇到和《库存扣多了，到底怎么整》文章中一样的并发一致性问题。

redis的WATCH和EXEC可以提供类似事务的机制：
•WATCH观察key是否被改动
•如果提交时key被改动，EXEC将返回null，表示事务失败
上面保证一致性的库存扣减可能类似于这样执行：
WATCH key
$num = GET key
$num = $num - $count
MULTI
SET key $num
EXEC

在WATCH之后，EXEC执行之前，如果key的值发生变化，则EXEC会失败。

redis的WATCH为何能够保证事务性，本质上，它使用的就是乐观锁CAS机制。

大部分情况下，redis不同的客户端会访问不同的key，所以WATCH碰撞的概率会比较小，在秒杀的业务场景，即使使用WATCH，调用侧仍然需要重试。

在CAS机制这一点上，redis和mysql相比没有额外的优势。

redis的性能之所以高，还是redis内存访问与mysql数据落盘的差异导致的。内存访问的不足是，数据具备“易失性”，如果重启，可能导致数据的丢失。当然redis也可以固化数据，难道每次都刷盘？redis真心没法当作mysql用。

最后，redis用单线程来避免物理锁，但mysql多线程也有多线程并发的优势。

回答：可以使用redis的事务性扣减库存，但在CAS机制上比mysql没有优势，高性能是因为其内存存储的原因，带来的副作用是数据有丢失风险，具体怎么用，还得结合业务折衷（任何脱离业务的架构设计都是耍流氓）。

留言三
支持幂等能否使用客户端token，业务流水？
能否使用时间戳，版本号来保证一致性？
回答：可以。

留言四
能否使用队列，在数据库侧串行执行，降低锁冲突？
回答：可以。

留言五
能否使用事务？
回答：容易死锁，吞吐量很低，不建议。

留言六
能否使用分布式锁解决，例如setnx, mc, zookeeper？
回答：可以，但吞吐量真的高么。

留言七
文章重点讲了幂等性和一致性，没有深入展开讲高吞吐，利用缓存抗读请求，利用水平扩展增加性能是提升吞吐量的根本方案。
回复：很中肯。

留言1-7代表了评论的多个观点，由于时间有限，《库存扣多了，到底怎么整》许多地方没有讲清楚，大伙见谅。