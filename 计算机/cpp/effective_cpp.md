# effective cpp

## 1. 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL)

## 2. 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define）

对于单纯常量，使用const或者enums代替#defines
对于形似函数的宏，使用inline代替

## 3. 尽可能使用 const

- const 可以让编译器帮助完成值不变的约束。可以用在作用域内的对象，函数参数，函数返回类型，成员函数本身。
    const 出现在*左边，表示被指物是常量。
    const 出现在*右边，表示指针本身是常量
- 编译器默认使用bitwise constness，但编写程序时应使用概念上的常量性（const用于成员函数时）
    bitwise：成员函数不改变对象的任何成员属性
    概念性：一个const成员函数可以修改处理对象的某些属性（在对客户端透明的情况下）

- 当const和non-const成员函数有着实质等价的实现时，另non-const版本调用const版本。

## 4. 确定对象被使用前已先被初始化(构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高)

- 通常使用类C部分的c++代码，不会保证初始化，而使用c++的部分代码会保证初始化（Oriented C++、Template C++、STL）
- 永远在使用对象前进行初始化
- 在构造函数中将每一个属性都进行初始化（使用成员初始化列表而不是在构造函数中进行赋值）(默认构造函数通常效率较低因为多了一步赋值过程)
- 为避免跨编译单元初始化次序问题，以 __local static__ 对象替换 __non-local static__ 对象（单例模式*）

## 5. 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）

- copy  将来源对象的每一个non-static成员变量拷贝到目标对象
- copy assignment cpp不会自动生成内含reference成员的类的赋值操作 __operator=__,如果基类的修饰符是private，则不会为派生类生成代码
- deconstructor  给编译器一个地方，放置默认代码且编译器产出的析构函数是non-virtual的
- constructor

## 6. 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）

- 将不想使用的成员函数声明为 private，并且不予实现，或者使用像Uncopyable这样的基类也可以

## 7. 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）

- 如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数
- 如果一个类不是作为基类使用，则不应该为析构函数加virtual

## 8. 别让异常逃离析构函数

- 析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常
- 如果要处理异常应该在非析构的普通函数处理

## 9. 绝不在构造和析构过程中调用 virtual 函数

- 因为这类调用从不下降至 derived class

## 10. 令operator= 返回一个 reference to *this

- 一条cpp协议

## 11. 在operator中处理自我赋值

- 证同测试
- 确保对象自我赋值时不会出错
- 确保任何函数操作一个以上的对象时，其中多个对象是同一个对象时，其行为仍热正确

## 12. 复制对象时，不要忘记每一个成分

- 不要尝试以某个copy函数实现另一个copy函数，应该将共同逻辑放入第三个函数中，然后由前两个copy函数共同调用

## 13. 以对象管理资源

- 将资源放入对象内，便可通过cpp的"析构函数自动调用"机制确保资源被释放
- RAII（资源取得时机就是初始化时机）
- 别让多个auto_ptr指向同一个对象
- 两个常使用的RAII对象是 shared_ptr 和 auto_ptr，前者通常是较佳选择，copy行为比较直观，auto_ptr 复制动作会使被复制物指向null

## 14. 在资源管理类中小心copy行为

- 单例模式，锁对象禁止复制
- 常用的copy行为有 禁止复制 引用计数等

## 15. 在资源管理类中提供对原始资源的访问

- API通常需要对原始资源进行访问，所以RAII 类应该提供一个获取原始资源的方法
- 对原始资源的访问可以提供显式或隐式两种方案，显式安全，隐式方便使用

## 16. new和delete成对使用，采用相同形式

- new 时使用 __[]__ delete时也要使用 __[]__

## 17 使用独立语句将 new 之后的对象置入智能指针

- 因为new时可能会抛出异常，可能会导致难以察觉的内存泄漏

## 18. 让接口容易被正确使用，不易被错误使用

- 所有好的接口都满足容易被正确使用，不易被错误使用
- 促进正确使用的办法包括：接口一致，与内置类型的行为兼容
- 阻止误用的办法有：建立新类型，限制类型上的操作，束缚对象值，消除客户端的资源管理责任
- shared_ptr支持定制型删除器，可防范DDL问题，可被用来自动解除互斥锁.(*)

## 19. 设计类犹如设计type

创建一个新类需要谨慎思考

- 新的类应该如何被创建和销毁
- 对象的初始化和赋值应该有什么样的差别
- 新对象如果以值传递，需要考虑什么
- 什么新type的合法值
- 是否要继承其他类，因此带来的约束
- 需要什么样的转换
- 什么样的操作符和函数对类是合理的
- 什么样的标准函数应该驳回
- 谁可以调用新类的成员（确定各成员的可访问级别）
- 什么是新类的未声明接口
- 新type有多一般化，是否换成class template
- 是否真的需要一个新类

## 20 用 pass-by-reference-to-const 替换 pass-by-value

- 前者更高效，可避免切割问题
- 对内置类型和stl的迭代器和函数对象不适用

## 21 必须返回对象时，不要反回引用

- 不要反回一个指向local 对象的指针或引用。或返回引用指向一个heap-allocated对象

## 22 将成员变量声明为private

- 保持一致性，不用考虑哪些对象需要使用括号访问
- 对变量实现精细化控制
- 封装
- protected 并不比 public 更具封装性

## 23 Prefer non-member,non-friend functions to member functions

- 数据应该尽可能被封装
- 尽量用non-member,non-friend函数代替member function，可以增加数据的封装性，包裹弹性和技能扩充性。

## 24 若所有参数都需要类型转换，采用non-memberfunction

- 如果需要对所有参数都进行类型转换，那么这个函数必须是个non-member函数。

## 25 考虑写出一个不抛异常的swap函数(*)

## 26 尽量延后变量定义式的出现时间

- 可以提高程序清晰度和代码效率

## 27 尽量少进行转型操作（*）

## 28 避免返回handlers指向对象内部成分

- 可增加封装性，使const对象的行为更像一个const，并将悬空handlers的可能性降低

## 29 尽量做到异常安全

- 异常安全应做到：不泄漏任何资源，不允许数据败坏
- 异常函数的三个保证：
  1.基本保证：异常抛出，程序内任何事物保持有效
  2.强烈保证：如果异常被抛出，程序状态不改变
  3.nothrow 保证：不向外扩散异常

- copy and swap:要改动的地方，先做拷贝，在拷贝上修改，修改成功后swap，若出错，删除副本即可
- 函数提供的"异常安全保证"，最多只能等于其所调用的所有函数的"异常安全保证"中的最弱者

## 30 透彻了解inline（*）

- inline 用在小型，被频繁调用的函数身上。
- 不要只因为function templates出现在头文件，就声明为inline

## 31 将编译依赖关系降至最低（*）

## 32 确保public继承塑膜出is-a 的关系

- public继承意味着is-a关系，适用于base-class 也必适用于drived-class。

## 33 避免遮掩继承而来的名称

- 派生类内的名称会遮掩基类的名称
- 为了让被遮掩的名称重见天日，可使用using生命式或者转交函数

## 34 区分接口继承和实现继承

- 接口继承和实现继承不同。在public继承下，派生类总是继承基类的接口
- 纯虚函数，只具体指定接口继承
- 非纯虚函数，具体指定接口继承及缺省实现继承
- 非虚函数，指定接口继承以及强制性继承
  
## 35 考虑virtual函数以外的其他选择（*）

- virtual 函数的替代方案包括NVI手法及策略模式的多种形式

## 36 禁止重新定义继承来的非虚函数 (*)

## 37 绝不重新定义继承而来的缺省参数值

- 可以使用35条NVI的方法替换
  
## 38 通过复合塑膜出 has-a 或者"根据某物实现出"

## 39 明智，审慎的使用private继承 （*）

## 40 多重继承(*)

## 41 了解隐式接口和编译器多态

- classes 和 templates 都支持接口和多态
- 对class而言接口是显式的，以函数签名为中心，多态则通过virtual函数发生于运行期
- 对template而言，接口是隐式的，奠基于有效表达式。多态通过template具现化和函数重载解析发生于编译期
  
## 42 typename双重意义
